"""ReleaseAgent: automates versioned GitHub releases with auto-generated changelogs."""

import os
import sys
import traceback
from itertools import islice
from typing import Optional, Tuple

from github import Github  # type: ignore


class ReleaseAgent:
    """Creates versioned GitHub releases with auto-generated changelogs.

    Only strict semantic version tags of the form ``vX.Y.Z`` are considered when
    computing the latest version and generating changelogs. Pre-release tags like
    ``v1.2.3-rc.1`` are ignored for these calculations.

    Parameters
    ----------
    repo_name:
        Full repository name in ``owner/repo`` format.
    """

    def __init__(self, repo_name: str) -> None:
        token = os.getenv("GITHUB_TOKEN")
        self.github = Github(token)
        self.repo = self.github.get_repo(repo_name)
        self._cached_highest_semver: Optional[Tuple[object, Tuple[int, int, int]]] = None

    @staticmethod
    def _parse_semver(tag_name: str) -> Optional[Tuple[int, int, int]]:
        """Parse a strict semver tag like ``v1.2.3`` into ``(1, 2, 3)``.

        Non-strict tags (e.g. prereleases like ``v1.2.3-rc.1``) return *None*.
        """
        if not tag_name.startswith("v"):
            return None
        version = tag_name[1:]
        parts = version.split(".")
        if len(parts) != 3:
            return None
        try:
            major, minor, patch = (int(p) for p in parts)
        except ValueError:
            return None
        return (major, minor, patch)

    def _get_highest_semver_tag(self) -> Optional[Tuple[object, Tuple[int, int, int]]]:
        """Return the tag with the numerically-highest semantic version.

        Note: this iterates all repository tags and caches the result on the agent
        instance.
        """
        if self._cached_highest_semver is not None:
            return self._cached_highest_semver

        best_version: Optional[Tuple[int, int, int]] = None
        best_tag = None
        for tag in self.repo.get_tags():
            parsed = self._parse_semver(tag.name)
            if parsed is None:
                continue
            if best_version is None or parsed > best_version:
                best_version = parsed
                best_tag = tag
        if best_tag is None or best_version is None:
            return None

        self._cached_highest_semver = (best_tag, best_version)
        return self._cached_highest_semver

    def refresh_tags_cache(self) -> None:
        """Clear cached tag information so subsequent calls re-scan tags."""
        self._cached_highest_semver = None

    def create_release(self, version: str) -> str:
        """Create a GitHub release tagged *version*.

        This method is GitHub-API-driven and does not require a local git checkout.
        If the tag does not exist, GitHub will create it pointing at the default
        branch tip.

        The changelog is generated by comparing the highest existing strict-semver
        tag (``vX.Y.Z``) against the default branch head.

        If there is no prior strict-semver tag, the changelog is capped to the
        most recent 200 commits.

        Parameters
        ----------
        version:
            Semantic version string, e.g. ``v0.1.0``.

        Returns
        -------
        str
            URL of the newly created release.
        """
        parsed_version = self._parse_semver(version)
        if parsed_version is None:
            raise ValueError(f"Invalid semantic version: {version}")

        branch = self.repo.default_branch
        branch_sha = self.repo.get_branch(branch).commit.sha

        last = self._get_highest_semver_tag()

        if last is not None:
            last_tag, last_version = last
            if parsed_version <= last_version:
                raise ValueError(
                    f"Version {version} must be greater than the latest strict semver tag {last_tag.name}"
                )

        if last is not None:
            last_tag, _ = last
            commits = self.repo.compare(last_tag.commit.sha, branch_sha).commits
        else:
            commits = list(islice(self.repo.get_commits(sha=branch_sha), 200))

        changelog = "\n".join(
            f"- {commit.commit.message.splitlines()[0]}" for commit in commits
        )

        release = self.repo.create_git_release(
            tag=version,
            name=f"Omni-Agent {version}",
            message=f"## Changelog\n\n{changelog}",
            target_commitish=branch_sha,
        )
        return release.html_url

    def next_version(self) -> str:
        """Compute the next patch-level semantic version.

        Returns
        -------
        str
            Next version string, e.g. ``v0.1.1``.
        """
        last = self._get_highest_semver_tag()
        if last is None:
            return "v0.1.0"

        _, (major, minor, patch) = last
        return f"v{major}.{minor}.{patch + 1}"


if __name__ == "__main__":
    agent = ReleaseAgent("wildhash/omni-agent")
    try:
        version = agent.next_version()
        url = agent.create_release(version)
    except ValueError as exc:
        print(f"Error creating release: {exc}", file=sys.stderr)
        raise SystemExit(1) from exc
    except Exception as exc:
        print(f"Unexpected error: {exc}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        raise SystemExit(1) from exc
    else:
        print(f"Release created: {url}")
